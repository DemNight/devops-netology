1) Какого типа команда cd? Попробуйте объяснить, почему она именно такого типа; опишите ход своих мыслей, если считаете что она могла бы быть другого типа.

cd является внутренней командой ос. Проще делать смену директории находясь внутри любой директории ос, не вызывая внешней "оплётки" со своим окружением. 

2) Какая альтернатива без pipe команде grep <some_string> <some_file> | wc -l? man grep поможет в ответе на этот вопрос. Ознакомьтесь с документом о других подобных некорректных вариантах использования pipe.

vagrant@vagrant:~$ cat test-1
11
22
33
44
55
vagrant@vagrant:~$ grep 22 test-1 -c
1
vagrant@vagrant:~$ grep 22 test-1 -c | wc -l
1

3)Какой процесс с PID 1 является родителем для всех процессов в вашей виртуальной машине Ubuntu 20.04?

vagrant@vagrant:~$ pstree -p
systemd(1)─┬─VBoxService(814)─┬─{VBoxService}(815)
           │                  ├─{VBoxService}(816)
           │                  ├─{VBoxService}(817)
           │                  ├─{VBoxService}(818)
           │                  ├─{VBoxService}(819)
           │                  ├─{VBoxService}(820)
           │                  ├─{VBoxService}(821)
           │                  └─{VBoxService}(822)
.

4) Как будет выглядеть команда, которая перенаправит вывод stderr ls на другую сессию терминала?

vagrant@vagrant:~$ ls -l /dev/pts/0 2>/dev/pts/1

vagrant@vagrant:~$ who
vagrant  pts/0        2021-11-21 18:34 (10.0.2.2)
vagrant  pts/1        2021-11-21 18:55 (10.0.2.2)
vagrant  pts/2        2021-11-21 19:02 (10.0.2.2)


5) Получится ли одновременно передать команде файл на stdin и вывести ее stdout в другой файл? Приведите работающий пример.

vagrant@vagrant:~$ cat test-1
11
22
33
44
55
vagrant@vagrant:~$ cat <test-1> test-1-out
vagrant@vagrant:~$ cat test-1-out
11
22
33
44
55

6) Получится ли находясь в графическом режиме, вывести данные из PTY в какой-либо из эмуляторов TTY? Сможете ли вы наблюдать выводимые данные?

Да, получится с использованием перенаправления (и наличием достаточных прав у пользователя)

vagrant@vagrant:/$ echo hello to tty2 > dev/tty2

(добавил скриншот)

7) Выполните команду bash 5>&1. К чему она приведет? Что будет, если вы выполните echo netology > /proc/$$/fd/5? Почему так происходит?

bash 5>&1 - будет создан дискриктор 5, который будет перенаправлен stdout
echo netology > /proc/$$/fd/5 - если дескритор создан, команда отработает, на экране появится надпись "netology", если нет - получим ошибку "файл или директория не существует"

8) Получится ли в качестве входного потока для pipe использовать только stderr команды, не потеряв при этом отображение stdout на pty? Напоминаем: по умолчанию через pipe передается только stdout команды слева от | на stdin команды справа. Это можно сделать, поменяв стандартные потоки местами через промежуточный новый дескриптор, который вы научились создавать в предыдущем вопросе.

Да, можно собрать "цепочку" перенаправлений 

Выглядеть будет примерно так: ls -l 5>&2 2>&1 1>&5 |grep some -c

9) Что выведет команда cat /proc/$$/environ? Как еще можно получить аналогичный по содержанию вывод?

Переменные среды

можно использовать команду: env

10) Используя man, опишите что доступно по адресам /proc/<PID>/cmdline, /proc/<PID>/exe.

/proc/<PID>/exe - ссылка до файла запущенного для процесса с указанным PID
/proc/<PID>/cmdline - полный путь до исполняемого файла процесса с указанным PID

11) Узнайте, какую наиболее старшую версию набора инструкций SSE поддерживает ваш процессор с помощью /proc/cpuinfo.

grep sse /proc/cpuinfo

sse4.2

12) При открытии нового окна терминала и vagrant ssh создается новая сессия и выделяется pty. Это можно подтвердить командой tty, которая упоминалась в лекции 3.2. Однако:

vagrant@netology1:~$ ssh localhost 'tty'
not a tty

то, что смог найти (вроде, похоже на правду) и если я правильно понял:

По умолчанию TTY, при выполнении команды (ssh) на удалённой машине, не выделяется. если запустить без удалённой команды, он стартанёт. но будет ждать открытия оболочки. оболочка не запустится, тк по умолчанию tty не выделяется. 

Если требуется запустится в таком варианте, интернет, советует использовать ключ -t

ssh -t localhost 'tty'

13)Бывает, что есть необходимость переместить запущенный процесс из одной сессии в другую. Попробуйте сделать это, воспользовавшись reptyr. Например, так можно перенести в screen процесс, который вы запустили по ошибке в обычной SSH-сессии.

Провёл тест по описанию из документации (https://github.com/nelhage/reptyr)

в сессии 1 запустил top (получил список процессов)
отправил в фон по ctrl+z, bg

получил pid процесса (1112)

сделал disown top (проверил, что отображается в выводе ps -a)

запустил ещё одну сессию ssh, выполнил reptyr 1112

получил таблицу top во второй сессии 


при первой попытке запуска reptyr получил ошибку: 

Unable to attach to pid 1780: Operation not permitted
The kernel denied permission while attaching. If your uid matches
the target's, check the value of /proc/sys/kernel/yama/ptrace_scope.
For more information, see /etc/sysctl.d/10-ptrace.conf

Выставил значение (по инструкции из интернета): kernel.yama.ptrace_scope = 0

14) sudo echo string > /root/new_file не даст выполнить перенаправление под обычным пользователем, так как перенаправлением занимается процесс shell'а, который запущен без sudo под вашим пользователем. Для решения данной проблемы можно использовать конструкцию echo string | sudo tee /root/new_file. Узнайте что делает команда tee и почему в отличие от sudo echo команда с sudo tee будет работать.

tee - команда, принимает данные на вход с одного источника и может выводить на несколько

В данном случае, команда выполняется с повышенными правами и выводит данные в два источника: в stdout и в указанный файл (new_file) 
