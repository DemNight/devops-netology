# devops-netology
## какое-то из первых дз

1) система исключит файлы с именем .tfvars (скрытый файл?)

2) файлы с именем ("точное имя")

override.tf
override.tf.json

а так же все файлы имеющие "хвост" (после нижнего подчёркивания, включая само подчёркивание)

_override.tf
_override.tf.json

3) будут игнорироваться файлы 

с именем .terraformrc (скрытый файл?)
и файл с именем terraform.rc


# 3.1. Работа в терминале, лекция 1

1) Установите средство виртуализации Oracle VirtualBox.
```
Сделано
```
2) Установите средство автоматизации Hashicorp Vagrant.
```
Сделано
```
3) В вашем основном окружении подготовьте удобный для дальнейшей работы терминал.
```
сделано
```
4) С помощью базового файла конфигурации запустите Ubuntu 20.04 в VirtualBox посредством Vagrant:

Создайте директорию, в которой будут храниться конфигурационные файлы Vagrant. В ней выполните vagrant init. Замените содержимое Vagrantfile по умолчанию следующим:

 Vagrant.configure("2") do |config|
 	config.vm.box = "bento/ubuntu-20.04"
 end
 
Выполнение в этой директории vagrant up установит провайдер VirtualBox для Vagrant, скачает необходимый образ и запустит виртуальную машину.
```
Сделано
```
5) Ознакомьтесь с графическим интерфейсом VirtualBox, посмотрите как выглядит виртуальная машина, которую создал для вас Vagrant, какие аппаратные ресурсы ей выделены. Какие ресурсы выделены по-умолчанию?
```
2 cpu,
1024 ram,
64 gb на жёстком диске (динамический жёсткий диск, занято 1.75 гб),
подключена сеть
9 мб видеопамяти
```
6) Ознакомьтесь с возможностями конфигурации VirtualBox через Vagrantfile: документация. Как добавить оперативной памяти или ресурсов процессора виртуальной машине?
```
путём добавления в файл конфигурации строк:

config.vm.provider "virtualbox" do |v|

  v.memory = указать_объём_памяти_(мб)
  
  v.cpus = указать_количество_ядер_цп
  
end
```
7) Команда vagrant ssh из директории, в которой содержится Vagrantfile, позволит вам оказаться внутри виртуальной машины без каких-либо дополнительных настроек. Попрактикуйтесь в выполнении обсуждаемых команд в терминале Ubuntu.
```
Подключение установлено
```
8) Ознакомиться с разделами man bash, почитать о настройках самого bash:

- какой переменной можно задать длину журнала history, и на какой строчке manual это описывается?
```
HISTFILESIZE

стр 1 строка 778
```
- что делает директива ignoreboth в bash?
```
Не сохраняет в истории команды повторяющиеся и начинающиеся с пробела команды
```
9) В каких сценариях использования применимы скобки {} и на какой строчке man bash это описано?
```
в сценариях когда требуется одновременно создать\удалить множество директорий и\или файлов, изменить права доступак ним, переместить в другие директории

стр 1 строка 1001
```
10) С учётом ответа на предыдущий вопрос, как создать однократным вызовом touch 100000 файлов? Получится ли аналогичным образом создать 300000? Если нет, то почему?
```
touch ИМЯ_ФАЙЛА{1..100000}

300000 не получится, тк слижком большое значение аргумента (ограничение ОС)
```
11) В man bash поищите по /\[\[. Что делает конструкция [[ -d /tmp ]]
```
проверяет условие -d /tmp, наличие каталога и возвращает 1 или 0 (истина\ложь) в зависимости от результатов проверки.
```
12)Основываясь на знаниях о просмотре текущих (например, PATH) и установке новых переменных; командах, которые мы рассматривали, добейтесь в выводе type -a bash в виртуальной машине наличия первым пунктом в списке:
```
mkdir /tmp/new_path_directory/
cp /bin/bash /tmp/new_path_directory/
PATH=/tmp/new_path_directory/:$PATH
type -a bash

bash is /tmp/new_path_directory/bash
bash is /usr/bin/bash
bash is /bin/bash

(добавил скриншот)
```
13)Чем отличается планирование команд с помощью batch и at?
```
at - запускает выполнение задач в заданное время (однократный запуск).

batch - позволяет запустить задачи, когда средняя нагрузка на систему ниже указанной (до этого момента, задачи висят в очереди).  
```
14) Завершите работу виртуальной машины чтобы не расходовать ресурсы компьютера и/или батарею ноутбука.
```
работа завершена (sudo shutdown -h now)
```


# 3.2. Работа в терминале, лекция 2

1) Какого типа команда cd? Попробуйте объяснить, почему она именно такого типа; опишите ход своих мыслей, если считаете что она могла бы быть другого типа.
```
cd является внутренней командой ос. Проще делать смену директории находясь внутри любой директории ос, не вызывая внешней "оплётки" со своим окружением. 
```
2) Какая альтернатива без pipe команде grep <some_string> <some_file> | wc -l? man grep поможет в ответе на этот вопрос. Ознакомьтесь с документом о других подобных некорректных вариантах использования pipe.
```
vagrant@vagrant:~$ cat test-1
11
22
33
44
55
vagrant@vagrant:~$ grep 22 test-1 -c
1
vagrant@vagrant:~$ grep 22 test-1 -c | wc -l
1
```
3)Какой процесс с PID 1 является родителем для всех процессов в вашей виртуальной машине Ubuntu 20.04?
```
vagrant@vagrant:~$ pstree -p
systemd(1)─┬─VBoxService(814)─┬─{VBoxService}(815)
           │                  ├─{VBoxService}(816)
           │                  ├─{VBoxService}(817)
           │                  ├─{VBoxService}(818)
           │                  ├─{VBoxService}(819)
           │                  ├─{VBoxService}(820)
           │                  ├─{VBoxService}(821)
           │                  └─{VBoxService}(822)

```
4) Как будет выглядеть команда, которая перенаправит вывод stderr ls на другую сессию терминала?
```
vagrant@vagrant:~$ ls -l /dev/pts/0 2>/dev/pts/1

vagrant@vagrant:~$ who
vagrant  pts/0        2021-11-21 18:34 (10.0.2.2)
vagrant  pts/1        2021-11-21 18:55 (10.0.2.2)
vagrant  pts/2        2021-11-21 19:02 (10.0.2.2)
```

5) Получится ли одновременно передать команде файл на stdin и вывести ее stdout в другой файл? Приведите работающий пример.
```
vagrant@vagrant:~$ cat test-1
11
22
33
44
55
vagrant@vagrant:~$ cat <test-1> test-1-out
vagrant@vagrant:~$ cat test-1-out
11
22
33
44
55
```
6) Получится ли находясь в графическом режиме, вывести данные из PTY в какой-либо из эмуляторов TTY? Сможете ли вы наблюдать выводимые данные?
```
Да, получится с использованием перенаправления (и наличием достаточных прав у пользователя)

vagrant@vagrant:/$ echo hello to tty2 > dev/tty2

(добавил скриншот)
```
7) Выполните команду bash 5>&1. К чему она приведет? Что будет, если вы выполните echo netology > /proc/$$/fd/5? Почему так происходит?
```
bash 5>&1 - будет создан дискриктор 5, который будет перенаправлен stdout
echo netology > /proc/$$/fd/5 - если дескритор создан, команда отработает, на экране появится надпись "netology", если нет - получим ошибку "файл или директория не существует"
```
8) Получится ли в качестве входного потока для pipe использовать только stderr команды, не потеряв при этом отображение stdout на pty? Напоминаем: по умолчанию через pipe передается только stdout команды слева от | на stdin команды справа. Это можно сделать, поменяв стандартные потоки местами через промежуточный новый дескриптор, который вы научились создавать в предыдущем вопросе.
```
Да, можно собрать "цепочку" перенаправлений 

Выглядеть будет примерно так: ls -l 5>&2 2>&1 1>&5 |grep some -c
```
9) Что выведет команда cat /proc/$$/environ? Как еще можно получить аналогичный по содержанию вывод?
```
Переменные среды

можно использовать команду: env
```
10) Используя man, опишите что доступно по адресам /proc/<PID>/cmdline, /proc/<PID>/exe...

/proc/<PID>/exe - ссылка до файла запущенного для процесса с указанным PID
/proc/<PID>/cmdline - полный путь до исполняемого файла процесса с указанным PID

11) Узнайте, какую наиболее старшую версию набора инструкций SSE поддерживает ваш процессор с помощью /proc/cpuinfo.

grep sse /proc/cpuinfo

sse4.2

12) При открытии нового окна терминала и vagrant ssh создается новая сессия и выделяется pty. Это можно подтвердить командой tty, которая упоминалась в лекции 3.2. Однако:

vagrant@netology1:~$ ssh localhost 'tty'
not a tty

то, что смог найти (вроде, похоже на правду) и если я правильно понял:

По умолчанию TTY, при выполнении команды (ssh) на удалённой машине, не выделяется. если запустить без удалённой команды, он стартанёт. но будет ждать открытия оболочки. оболочка не запустится, тк по умолчанию tty не выделяется. 

Если требуется запустится в таком варианте, интернет, советует использовать ключ -t

ssh -t localhost 'tty'

13)Бывает, что есть необходимость переместить запущенный процесс из одной сессии в другую. Попробуйте сделать это, воспользовавшись reptyr. Например, так можно перенести в screen процесс, который вы запустили по ошибке в обычной SSH-сессии.

Провёл тест по описанию из документации (https://github.com/nelhage/reptyr)

в сессии 1 запустил top (получил список процессов)
отправил в фон по ctrl+z, bg

получил pid процесса (1112)

сделал disown top (проверил, что отображается в выводе ps -a)

запустил ещё одну сессию ssh, выполнил reptyr 1112

получил таблицу top во второй сессии 


при первой попытке запуска reptyr получил ошибку: 

Unable to attach to pid 1780: Operation not permitted
The kernel denied permission while attaching. If your uid matches
the target's, check the value of /proc/sys/kernel/yama/ptrace_scope.
For more information, see /etc/sysctl.d/10-ptrace.conf

Выставил значение (по инструкции из интернета): kernel.yama.ptrace_scope = 0

14) sudo echo string > /root/new_file не даст выполнить перенаправление под обычным пользователем, так как перенаправлением занимается процесс shell'а, который запущен без sudo под вашим пользователем. Для решения данной проблемы можно использовать конструкцию echo string | sudo tee /root/new_file. Узнайте что делает команда tee и почему в отличие от sudo echo команда с sudo tee будет работать.

tee - команда, принимает данные на вход с одного источника и может выводить на несколько

В данном случае, команда выполняется с повышенными правами и выводит данные в два источника: в stdout и в указанный файл (new_file) 
